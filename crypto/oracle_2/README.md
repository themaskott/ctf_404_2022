## CRYPTANALYSE / Un simple oracle 2/2

<p align="center">
  <img src="img/consignes.png" />
</p>


### Look around

Nous avons à disposition une interface pour interagir avec un oracle :

```bash
nc challenge.404ctf.fr 30594
Il y a eu quelques petits problèmes lors de ma précédente itération, mais tout a été résolu!
Je peux à nouveau montrer mon secret sans craintes:
13435527312294828021115881312461451395375023001653703543403206511753763113496654560120146408373365455082237148285101364314027962495630186533764053724152066266633639483143473093224727339760280145019163520354387240958578326378800141350304841617939769279398745050671110948559260833541568994481529592654514878158546352332029737418044531992956977701504671509395670118875303497638634692841899684741670033398059327380595823997081562350504507007306326756807487193533438113881506299816680185106886859449830936179562088969925647038822672208635965865546530558286111134715621020267805496148394818852595099608886572106234980519872
Par mesure de sécurité, je ne peux malheureusement plus tout partager ici:
e = 65537

Ceci étant dit, passons à ce que vous vouliez me dire!

>
```


On se retrouve dans un situation similaire au challenge n°1, mais cette fois sans divulgation du modulus N de la part de l'oracle ...



### Attaque

Par chance nous avons la clef publique à disposition. On peut choisir un message `known` et le chiffrer : `knwon^e [N]`

On soumet alors à l'oracle : `(knwon^e) * (flag^e) = (knwon * flag)^e`

L'oracle nous retourne alors `(knwon * flag)^e^d = (knwon * flag)` où `d` est la clef privée.

Il reste plus qu'à multiplier par l'inverse de `knwon` pour récupérer le flag.

Avec le code suivant :

```python
from binascii import unhexlify
from Crypto.Util.number import inverse
import socket


def send_bytes(s, b):
	s.send(b.encode() + b'\n')
	rep = s.recv(2048)
	return rep


HOST = 'challenge.404ctf.fr'
PORT = 32128

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))

    rep = s.recv(2048)

    cipher_flag = int( rep.split(b'\n')[1].decode() )
    N = int( rep.split(b'\n')[3][4:].decode() )

    e = 65537

    print(f'{cipher_flag=}')
    print(f'{N=}')
    print(f'{e=}')

    # chosen plain text
    k = 5
    known = pow(k,e,N)

    rep = send_bytes(s, str(cipher_flag*known) )
    rep = int(rep.split(b'\n')[1].decode())

    inv = inverse(rep,N)

    flag = inverse(inv * k,N)
    flag = hex(flag)[2:]
    print(unhexlify(flag))
```


```bash
python3 solve_oracle_1.py
cipher_flag=21198353547407397210250581202757444083880640467249502818978186177701291446543591671380632394546552453468099475912504277616901048123493512731436043041262514799938658816454605478928814583641307022140302346672124245323728354727305889437056685450640076409492896102204593532082640866526597499360560899834867702428306420089614451283990494755156267450911004940482252253099912485672043227534420077925717787857166930652051387383265540948355947668544951266123062381336878486373134861134515793923683882390643862905371493031554279781595901714603476239144193978805699703885606880422765780156583245677261440573603696111254114035190
N=25322016711999466707450485835315332199395645340207447061557215779048537225363598004921490824242801357299514788676778276352411751614626656457817997113772147972847769312524383818342309103922928786400760013080848340858749696756180186211326802056225219517549559473419854659191757335021939001673098700801418302049330617069297406350635495159570641065650565945882828644088408552886896466243581008152377596104548842722262401635338911080565539193537704391633802500368666191648839440594231874313111284861613876812808866512347439191128659051937970104517322516267947244230740640091062705854471407223300548251059869341193920212399
e=65537
b'404CTF{L3s_0r4cl3s_RSA_s0n7_si_fr4g1l35}'
```
